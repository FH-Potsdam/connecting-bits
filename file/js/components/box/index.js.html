<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">js/components/box/index.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="git+https://github.com/FH-Potsdam/connecting-bits.git">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/index.js~BoardsChain.html">BoardsChain</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">components/box</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/components/box/index.js~Box.html">Box</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">components/infrared</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/components/infrared/index.js~Infrared.html">Infrared</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">components/light</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/components/light/index.js~Light.html">Light</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">components/microphone</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/components/microphone/index.js~Microphone.html">Microphone</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/components/microphone/records.js~Record.html">Record</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/components/microphone/reports.js~Report.html">Report</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/components/microphone/speechtotext.js~SpeechToText.html">SpeechToText</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">components/motor</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/components/motor/index.js~Motor.html">Motor</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">components/speaker</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/components/speaker/index.js~Speaker.html">Speaker</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">components/translator</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/components/translator/index.js~Translate.html">Translate</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">constants</div><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-GENERAL_CONSTANTS">GENERAL_CONSTANTS</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-INFRARED_CONSTANTS">INFRARED_CONSTANTS</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-LIGHT_CONSTANTS">LIGHT_CONSTANTS</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-MOTOR_CONSTANTS">MOTOR_CONSTANTS</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">utils</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/utils/boardsUtil.js~BoardsUtil.html">BoardsUtil</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/utils/clientsUtil.js~ClientsUtil.html">ClientsUtil</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/utils/logUtil.js~LogUtil.html">LogUtil</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">js/components/box/index.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import { Led } from &apos;johnny-five&apos;;
import config from &apos;config&apos;;
import Microphone from &apos;../microphone&apos;;
import Translator from &apos;../translator&apos;;
import Light from &apos;../light&apos;;
import Motor from &apos;../motor&apos;;
import Speaker from &apos;../speaker&apos;;
import Infrared from &apos;../infrared&apos;;
import logUtil from &apos;../../utils/logUtil&apos;;
import { GENERAL_CONSTANTS } from &apos;../../constants&apos;;
const {
	PAUSE_TIME_BETWEEN_INTERACTIONS
} = GENERAL_CONSTANTS;

/**
 * @class Box is the class that contains the methods for all actions a Box
 * should be able to perform. It takes care of orchestring the chain of
 * events.
 */
export default class Box {
	/**
	 * Constructor for the Light class
	 * @param {JohnnyFive board instanxe} board - this is the board class delivered
	 * by johnny five for one board. In this case we talk about a photon board
	 * @param {Mqtt client} client - This is an  instance of an mqtt client that
	 * will be used to communicate with oder boxes
	 * @param {Object} options - Option containing next, prev and isMaster
	 */
	constructor(board, client, options) {
		/**
		 * A Johnny Five Board instance
		 * @type {Board}
		 */
		this.board = board;
		/**
		 * An Mqtt client
		 * @type {Mqtt client}
		 */
		this.client = client;
		/**
		 * Option with next, prev and isMaster
		 * @type {Object}
		 */
		this.options = options;
		/**
		 * The Box&apos;s name
		 * @type {String}
		 */
		this.name = this.board.id;
		/**
		 * The round actually playing
		 * @type {Number}
		 */
		this.round = 0;

		// initialise subcomponents
		/**
		 * The Translator component
		 * Will be intialized when all boards are ready
		 * @type {[type]}
		 */
		this.translator = null;
		/**
		 * The Light component
		 * Will be intialized when all boards are ready
		 * @type {Light}
		 */
		this.light = null;
		/**
		 * The Motor component
		 * Will be intialized when all boards are ready
		 * @type {Motor}
		 */
		this.motor = null;
		/**
		 * The Speak component
		 * Will be intialized when all boards are ready
		 * @type {Speak}
		 */
		this.speaker = null;
		/**
		 * The Infra component
		 * Will be intialized when all boards are ready
		 * @type {Infra}
		 */
		this.infrared = null;
		/**
		 * The Micro component
		 * Will be intialized when all boards are ready
		 * @type {Micro}
		 */
		this.microphone = null;

		this.testMotor = this.testMotor.bind(this);

		client.on(&apos;connect&apos;, this.onConnect.bind(this));
		client.on(&apos;message&apos;, this.onMessage.bind(this));
	}
	/** Is called when the Box&apos;s mqtt client is ready and connected. */
	onConnect() {
		logUtil.log({
			type: &apos;shiftr&apos;,
			title: `Box &quot;${ this.name }&quot; connected and subscribed`,
			messages: [ { &apos;subscription topic&apos;: `/inputs/${ this.name }` } ]
		});
		this.client.subscribe(`/inputs/${ this.name }`);
		this.board.on(&apos;ready&apos;, this.onBoardReady.bind(this));
	}
	/**
	 * Is called when a mqtt message is received
	 * @param  {string} topic - the mqtt topic the message was sent on
	 * @param  {string} message - the message sent via mqtt
	 */
	onMessage(topic, message) {
		clearTimeout(this.interval);
		logUtil.log({
			type: &apos;shiftr&apos;,
			title: `Box &quot;${ this.name }&quot; received a message`,
			messages: [
				{ topic },
				{ message: message.toString() }
			]
		});

		switch (message.toString()) {
			case &apos;done&apos;:
				this.round++;
				this.prepareToSpeak.bind(this)();
				break;
			case &apos;readyToListen&apos;:
				this.speakText.bind(this)();
				break;
			case &apos;readyToSpeak&apos;:
				this.onPreviousBoxSpeaking.bind(this)();
				break;
			default: return;
		}
	}
	/**
	 * Send a message to wether the nex or the previous Box via mqtt
	 * @param  {string} message - message to be sent to the sibling Box
	 * @param  {string} recipient - wether &quot;next&quot; or &quot;prev&quot;
	 */
	sendMessage(message, recipient = &apos;next&apos;) {
		const recipientBox = this.options[ recipient ];
		if (!recipientBox) {
			logUtil.log({
				type: &apos;warning&apos;,
				title: `Box &quot;${ this.name }&quot; has an invalid next sibling`,
				messages: [
					{ sibling: recipientBox.name }
				]
			});
		}

		const topic = `/inputs/${ recipientBox.name }`;
		logUtil.log({
			type: &apos;shiftr&apos;,
			title: `Box &quot;${ this.name }&quot; forwarded a message`,
			messages: [
				{ from: this.name },
				{ to: recipientBox.name },
				{ topic },
				{ message }
			]
		});
		this.client.publish(topic, message);
	}
	/** Is called when the Photon board is ready */
	onBoardReady() {
		this.translator = new Translator(this.name, this.options.language);
		this.speaker = new Speaker(this.name, this.options.language);
		this.microphone = new Microphone(this.name, this.options.language);
		this.motor = new Motor(this.board);
		this.light = new Light(this.board);
		this.infrared = new Infrared(this.board);
		logUtil.log({
			type: &apos;hardware&apos;,
			title: `Box&apos;s board of &quot;${ this.name }&quot; is ready`
		});
	}
	/**
	 * Retruns the Box&apos;s mqtt client
	 * @return {Mqtt client instance}
	 */
	getClient() {
		return this.client;
	}
	/**
	 * Returns the Box&apos;s j5 board
	 * @return {Johnny Five board instance}
	 */
	getBoard() {
		return this.board;
	}
	/** Internal start, starts detecting */
	start() {
		this.motor.lieDown()
			.then(() =&gt; {
				logUtil.log({
					type: &apos;hardware&apos;,
					title: `Box&apos;s &quot;${ this.name }&quot; starts detecting`
				});
				this.infrared.detectPresence()
					.then(this.onPresenceDetected.bind(this));
			});
	}
	/** External start, intreases the round */
	startTheShow() {
		this.round++;
		logUtil.log({
			type: &apos;info&apos;,
			title: `Box &quot;${ this.name }&quot; starts the show`,
			messages: [ { round: this.round } ]
		});
		this.start.bind(this)();
	}
	/** Restarts the complete show and resets the round */
	restartTheShow() {
		this.round = 1;
		this.start.bind(this)();
	}
	/** Is called when the infrared detects a presence */
	onPresenceDetected() {
		logUtil.log({
			type: &apos;info&apos;,
			title: `Box &quot;${ this.name }&quot; detected a presence`
		});
		this.motor.standUp()
			.then(() =&gt; {
				this.motor.lookUp()
					.then(() =&gt; {
						this.speaker.explainRules()
							.then(this.onRulesExplained.bind(this))
							.catch(() =&gt; {
								logUtil.log({
									type: &apos;error&apos;,
									title: `Rules not explained`
								});
								this.motor.lookStraight()
									.then(this.startTheShow.bind(this));
							});
					});
			});
	}
	/** Is called when the Box has spoken the rules out loud */
	onRulesExplained() {
		logUtil.log({
			type: &apos;info&apos;,
			title: `Box &quot;${ this.name }&quot; explained the rules`
		});
		this.motor.lookStraight()
			.then(() =&gt; {
				this.light.startBlinking();
				this.microphone.startRecording()
					.then(() =&gt; {
						logUtil.log({
							type: &apos;info&apos;,
							title: `Box &quot;${ this.name }&quot; has successfully recorded a voice`
						});
						this.prepareToSpeak.bind(this)();
					})
					.catch(this.onRecordingFailed.bind(this));
			});
	}
	/** Is called when the Box is meant to speak */
	prepareToSpeak() {
		this.light.stopBlinking()
			.then(() =&gt; {
				const isLastRound = this.isLastRound.bind(this)();
				if (isLastRound) {
					this.speakText.bind(this)();
				} else {
					this.sendMessage.bind(this)(&apos;readyToSpeak&apos;);
				}
				logUtil.log({
					type: &apos;info&apos;,
					title: `Box &quot;${ this.name }&quot; is prepared to speak`,
					messages: [ { round: this.round } ]
				});
			});
	}
	/** Speaks the text out loud */
	speakText() {
		this.motor.lookUp()
			.then(() =&gt; {
				this.speaker.speakText()
					.then(this.onTextSpoken.bind(this))
					.catch((err) =&gt; {
						logUtil.log({
							type: &apos;warning&apos;,
							title: `Box &quot;${ this.name }&quot; failed to repeat the text`,
							messages: [ { then: &apos;Retries on time again&apos; } ]
						});
						this.motor.lookStraight()
							.then(() =&gt; {
								this.speaker.sayNoRecordingError()
									.then(this.startTheShow.bind(this));
							});
					});
			});
	}
	/**
	 * Is called when the voice was badly recorded, when no sound was identified
	 * or when the speech could not be transformed into text
	 */
	onRecordingFailed() {
		this.light.stopBlinking()
			.then(() =&gt; {
				logUtil.log({
					type: &apos;warning&apos;,
					title: `Box &quot;${ this.name }&quot; failed to record the voice`,
					messages: [ { then: &apos;Starts over again&apos; } ]
				});
				this.motor.lookUp()
					.then(() =&gt; {
						this.speaker.sayNoRecordingError()
							.then(this.startTheShow.bind(this));
					});
			});
	}
	/** Is called whe the box has successfully spoken the text out loud */
	onTextSpoken() {
		logUtil.log({
			type: &apos;info&apos;,
			title: `Box &quot;${ this.name }&quot; repeated the text`
		});
		this.motor.lookStraight()
			.then(() =&gt; {
				this.motor.lieDown()
					.then(this.handleTranslation.bind(this));
			});
	}
	/** Ends the show of the box */
	handleTranslation() {
		if (this.options.isMaster) {
			if (this.round === 1) {
				logUtil.log({
					type: &apos;info&apos;,
					title: `Box &quot;${ this.name }&quot;s is now translating`,
					messages: [
						{ next: this.options.next.name },
						{ &apos;from language&apos;: this.options.language },
						{ &apos;to language&apos;: this.options.next.language }
					]
				});
				this.translator.translateNext(this.options.next)
					.then(this.finish.bind(this));
			} else {
				logUtil.log({
					type: &apos;info&apos;,
					title: `Box &quot;${ this.name }&quot;s show is over`,
					messages: [ { then: &apos;Starts over again&apos; } ]
				});
				this.round = 0;
				this.startTheShow.bind(this)();
			}
		} else {
			this.translator.translateNext(this.options.next)
				.then(this.finish.bind(this));
		}
	}
	/** Is called when the box finished its round */
	finish() {
		logUtil.log({
			type: &apos;info&apos;,
			title: `Box &quot;${ this.name }&quot; finished its round`,
			messages: [ { round: this.round } ]
		});
		/** The component&apos;s timeout. Saved to be cleared at any time */
		this.timeout = setTimeout(() =&gt; {
			this.sendMessage.bind(this)(&apos;done&apos;);
			logUtil.log({
				type: &apos;info&apos;,
				title: `Box &quot;${ this.name }&quot;s show is over`
			});
		}, PAUSE_TIME_BETWEEN_INTERACTIONS);
	}
	/** Is called when the previous box is speaking the text out loud */
	onPreviousBoxSpeaking() {
		logUtil.log({
			type: &apos;info&apos;,
			title: `Box &quot;${ this.name }&quot; is listening to its previous sibling`
		});
		this.motor.standUp()
			.then(() =&gt; {
				this.light.startBlinking();
				this.motor.lookStraight()
					.then(() =&gt; {
						this.sendMessage.bind(this)(&apos;readyToListen&apos;, &apos;prev&apos;);
					});
			});
	}
	/** Is called to check is this is the last round */
	isLastRound() {
		return this.options.isMaster &amp;&amp; this.round &gt; 1;
	}
	/** A method to reinitialize the box to a standing state */
	allStandUp() {
		this.motor.standUp();
		this.motor.lookStraight();
	}
	/** A method to reinitialize the box to the initial state */
	reset() {
		this.motor.lieDown();
		this.motor.lookStraight();
		this.light.stopBlinking();
	}
	/** A method to test that all components are connected and working correctly */
	testMotor() {
		return new Promise((resolve, reject) =&gt; {
			this.delayedCall.bind(this)(this.motor.standUp)
				.then(() =&gt; {
					this.delayedCall.bind(this)(this.motor.lookUp)
						.then(() =&gt; {
							this.delayedCall.bind(this)(this.motor.lookStraight)
								.then(() =&gt; {
									this.delayedCall.bind(this)(this.motor.lieDown)
										.then(resolve);
								});
						});
				});
		});
	}
	/** A utility to delay an action returning a Promise */
	delayedCall(callback) {
		return new Promise((resolve) =&gt; {
			/** The component&apos;s timeout. Saved to be cleared at any time */
			this.timeout = setTimeout(() =&gt; {
				callback();
				clearTimeout(this.timeout);
				resolve();
			}, 1000);
		});
	}
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.3)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
